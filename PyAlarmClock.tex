\section{PyAlarmClock}
Pro usnadnění manipulace s budíkem připojeným přes rozhraní UART z počítače
byla vytvořena knihovna \texttt{PyAlarmClock}. Je to modul jazyka Python
obsahující abstrakce pro práci s budíkem. Programátor vytvářející počítačový
program díky tomu nemusí ani znát konkrétní příkazy prostředí
\texttt{AlarmClockCLI}. Například nastavení data času modulu RTC se provádí
přiřazením objektu \texttt{datetime.datetime} vlastnosti \verb|RTC_time|
objektu \texttt{AlarmClock} bez nutnosti znát vnitřní implementaci, která
využívá příkazu \texttt{st} pro nastavení času a \texttt{sd} pro nastavení
data.

Pro ilustraci konceptu poslouží jeden z ukázkových programů~--
\repopath{examples/set_time.py}. V následující ukázce je navíc odstraněna část
zapínající podrobné protokolování všech událostí.
\begin{lstlisting}[language=Python,style=numbers]
#!/usr/bin/env python3

import PyAlarmClock
from datetime import datetime
import time

with PyAlarmClock.SerialAlarmClock('/dev/ttyUSB0') as ac:
    ac.RTC_time = datetime.now()
    time.sleep(1.65)  # RTC is polled every 0.8 seconds
    print(ac.RTC_time)
\end{lstlisting}
Program naváže spojení s budíkem, nastaví čas uložený v RTC na aktuální čas,
počká \SI{1,65}{\second} (aby stihl firmware budíku přečíst novou hodnotu
z RTC) a vypíše do konzole čas přečtený z budíku.
\begin{lstlisting}[style=terminal]
$ ./set_time.py
2022-02-08 19:21:48
$
\end{lstlisting}


\subsection{MQTT adaptér}
Jedním z programů využívajících knihovnu \texttt{PyAlarmClock} je
\repopath{examples/mqtt_bridge.py}. Tento program umožňuje vzdálené ovládání
budíku zprávami přenášenými protokolem MQTT. Tímto způsobem lze zajistit
ovládání budíku několika programy současně bez nutnosti sdílet sériový port
mezi více procesy. Komunikace může probíhat nejen mezi více zařízeními ve
stejné počítačové síti, ale i v rámci jednoho serveru (\texttt{localhost}).

Použití adaptéru je velmi jednoduché. Příkazem \verb|mqtt_bridge.py --help|
lze vypsat seznam argumentů, které lze programu předávat.
% nechci sem davat cely usage, protoze bych ho pak treba musel aktualizovat...
Následuje jednoduchý příklad~-- program se připojí k MQTT brokeru na
\texttt{localhost} na výchozím portu 1883 jako uživatel \texttt{DEBUG} s heslem
zadaným interaktivně za běhu programu:
\begin{lstlisting}[style=terminal]
$ ./examples/mqtt_bridge.py /dev/ttyUSB0 -u DEBUG
Password:
2022-02-08 19:22:39,360 INFO err topic: alarmclock/err
2022-02-08 19:22:39,360 INFO state topic: alarmclock/stat
2022-02-08 19:22:39,360 INFO command topic: alarmclock/cmnd
2022-02-08 19:22:39,361 INFO Connecting to MQTT on localhost:1883
2022-02-08 19:22:42,139 INFO MQTT connected with result code 0

\end{lstlisting}

Pomocí nástrojů ze softwarového balíčku \texttt{mosquitto-clients}
% https://packages.ubuntu.com/focal/mosquitto-clients
můžeme pozorovat, že program při spuštění odešle několik zpráv:
\begin{lstlisting}[style=terminal]
$ mosquitto_sub -v -t alarmclock/#
alarmclock/stat/available online
alarmclock/stat/number_of_alarms 6
\end{lstlisting}
Číslo posílané v topic \topic{alarmclock/stat/number_of_alarms} udává počet
konfigurovatelných časů buzení, které firmware připojeného budíku podporuje
(interně zjišťováno příkazem \texttt{ver}). Zpráva je adaptérem zasílána
s příznakem \texttt{retain}, proto je automaticky zaslána nově příchozímu
subscriberovi.

Zpráva v topic \topic{alarmclock/stat/available} určuje, zda je adaptér
aktivní. Při jeho ukončení či náhodném odpojení je MQTT brokerem do tohoto
topic automaticky zaslána zpráva \texttt{offline}. K tomu je využívána funkce
MQTT \ac{LWT}.

Požadujeme-li, aby budík provedl nějakou akci, pošleme zprávu do příslušného
\texttt{command topic} -- \topic{alarmclock/cmnd/nazev_prikazu}.
Toto je interně řešeno pomocí základních tříd \texttt{AlarmClockMQTT.Entity}
a \texttt{AlarmClockMQTT.Command}, ze kterých dědí třídy reprezentující
jednotlivé komponenty budíku. \texttt{Entity} reprezentuje komponentu mající
nějaký stav, který je možné na vyžádání přečíst
(\foreignlanguage{english}{polling}). \texttt{Command} reprezentuje příkaz,
který je možné spustit MQTT zprávou. Příkazy nemají žádný vlastní stav.
Třídy jednotlivých komponent mohou dědit z obou těchto základních tříd
zároveň~-- například \texttt{Switch} je přepínač, který lze vzdáleně ovládat
a jehož stav je možné i číst.

\begin{lstlisting}[language=Python]
class AlarmClockMQTT:
    """An MQTT adapter for AlarmClock."""

    class Entity:
        """Representation of an AlarmClock attribute with a pollable state."""

        def get_state(self, ac: AlarmClock):
            """Get state of the entity.

            Returns a result that should be published in the entity's
            state_topic.
            """
            raise NotImplementedError()

    class CommandError(Exception):
        """Error raised by a MQTT command handler."""

    class Command:
        """Representation of a MQTT command handler."""

        def do_command(self, ac: AlarmClock, msg: str):
            """Handle reception of msg.

            The return value (if not None) of this function will be published
            in the corresponding state_topic.

            If a tuple is returned, the first value in the tuple is a topic
            under state_topic where the second value should be published.

            If a list is returned, each item will be handled according to
            the above rules.
            """
            raise NotImplementedError()

    class Switch(Entity, Command):
        """A switch that can either be OFF or ON.

        e.g. lamp, inhibit
        """

        def __init__(self, name: str):
            """Initialize a switch.

            name must be a valid name of a AlarmClock attribute.
            """
            self.name = name

        def do_command(self, ac: AlarmClock, msg: str):
            messages = {
                'ON': lambda ac: self.turn_on(ac),
                'OFF': lambda ac: self.turn_off(ac),
                '?': lambda ac: None,  # empty lambda - only stat
                '': lambda ac: None,
            }

            msg = msg.upper()
            if msg in messages:
                messages[msg](ac)
                return self.get_state(ac)
            else:
                raise AlarmClockMQTT.CommandError()

        def turn_on(self, ac: AlarmClock):
            setattr(ac, self.name, True)

        def turn_off(self, ac: AlarmClock):
            setattr(ac, self.name, False)

        def get_state(self, ac: AlarmClock):
            value = getattr(ac, self.name)
            value = 'ON' if value else 'OFF'
            return value
\end{lstlisting}

Instance \texttt{AlarmClockMQTT} má svá asociativní pole
\texttt{ENTITIES} a \texttt{COMMANDS}, ve kterých jsou uloženy jednotlivé
instance entit a příkazů přiřazené ke svému \texttt{topic}.

\begin{lstlisting}[language=Python]
class AlarmClockMQTT:
    # ...

    def __init__(self, config: AlarmClockMQTTConfig):
        # ...
        ambient = self.DimmableLight('ambient')

        self.COMMANDS: Dict[str, AlarmClockMQTT.Command] = {
            'ambient': ambient,
            # ...
        }

        self.ENTITIES: Dict[str, AlarmClockMQTT.Entity] = {
            'ambient': ambient,
            # ...
        }
\end{lstlisting}

Pro všechny entity, které nejsou zároveň příkazem, je implementováno čtení na
vyžádání, které se provádí MQTT zprávou se znakem \texttt{?} v \texttt{payload}
zaslanou do \texttt{topic} \topic{alarmclock/cmnd/nazev_entity}. Odpověď je
zaslána do \topic{alarmclock/stat/nazev_entity}, \texttt{payload} zprávy je
určen konkrétní implementací metody \verb|get_state| v objektu dané entity.
Entity, které jsou zároveň příkazem (nebo čisté příkazy bez vlastního stavu),
musí zprávy s \lstinline[language=Python]!payload = '?'! v případě potřeby
ošetřit ve vlastní implementaci metody \verb|do_command|. Do
\topic{alarmclock/stat/nazev_entity} je poté zaslána hodnota vrácená touto
metodou. Informace o případných chybách jsou zasílány do
\topic{alarmclock/err}.

\begin{lstlisting}[language=Python]
class AlarmClockMQTT:
    # ...

    def _on_message(self, client, userdata, msg):
        if self._config.command_topic in msg.topic:
            command_id = remove_prefix(msg.topic,
                                       f'{self._config.command_topic}/')
            payload = msg.payload.decode('ascii')
            if command_id in self.COMMANDS:
                self._execute_command(client, command_id, payload)
            elif command_id in self.ENTITIES and payload == '?':
                entity_id = command_id
                self._report_state(client, entity_id)
            else:
                text = f'Bad topic for command: {msg.topic}'
                _LOGGER.error(text)
                client.publish(self._config.err_topic, text)

    def _report_state(self, client: mqtt.Client, entity_id: str):
        client.publish(f'{self._config.state_topic}/{entity_id}',
                       self.ENTITIES[entity_id].get_state(self.ac))

    def _execute_command(self, client: mqtt.Client, command_name: str,
                         msg: str):
        try:
            ret = self.COMMANDS[command_name].do_command(self.ac, msg)
            if ret is not None:
                if not isinstance(ret, list):
                    ret = [ret]
                for value in ret:
                    if isinstance(value, tuple):
                        topic, message = value
                        client.publish(f'{self._config.state_topic}/{topic}',
                                       message)
                    else:
                        client.publish(
                                f'{self._config.state_topic}/{command_name}',
                                value
                                )
        except self.CommandError as e:
            # ...
\end{lstlisting}

V následujícím příkladu je demonstrované rozsvícení připojeného světla
\texttt{lamp} vzdáleným MQTT příkazem a následné zhasnutí pomocí rozhraní na
displeji budíku. Pro přehlednost byly přidány prázdné řádky. První zpráva
v druhém bloku je příkaz pro rozsvícení lampy. V odpověď na ni přichází zpráva
v topic \topic{alarmclock/stat/lamp} značící, že byla lampa rozsvícena. Protože
firmware budíku podporuje funkci přidanou z vývojové větve
\texttt{feature/CLI-BEL}, posílá při každé změně stavu hardware na sériový port
netisknutelný ASCII znak BEL (\texttt{0x07}). V reakci na to si adaptér vyžádá
stav všech hardwarových výstupů a odešle příslušné MQTT zprávy. Zpráva o stavu
lampy je proto duplikována, je ale zajištěna zpětná kompatibilita s firmware
bez podpory funkce asynchronní detekce změn stavu hardware.
Díky této funkci je detekováno i vypnutí lampy přímo ovládacími prvky budíku,
které vede k odeslání třetího bloku zpráv.
\begin{lstlisting}[style=terminal]
$ mosquitto_sub -v -t alarmclock/#
alarmclock/stat/available online
alarmclock/stat/number_of_alarms 6

alarmclock/cmnd/lamp ON
alarmclock/stat/lamp ON
alarmclock/stat/lamp ON
alarmclock/stat/inhibit OFF
alarmclock/stat/ambient 0

alarmclock/stat/lamp OFF
alarmclock/stat/inhibit OFF
alarmclock/stat/ambient 0
\end{lstlisting}

\todo[inline]{dopsat mqtt bridge}
